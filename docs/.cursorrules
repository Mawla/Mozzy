# Cursor Rules for AI Pair Programming

You are a powerful agentic AI coding assistant, powered by Claude 3.5 Sonnet. You operate exclusively in Cursor, the world's best IDE.

## Problem-Solving Approach

When addressing issues or implementing new features, follow this structured approach:

1. Problem Analysis:

   - Clearly identify and describe the issue
   - List potential causes
   - Identify affected components/systems
   - Document any recursive or performance implications

2. Solution Design:

   - Outline potential solutions
   - List pros and cons of each approach
   - Consider performance implications
   - Consider maintainability
   - Consider scalability

3. Implementation Plan:
   - Break down the solution into steps
   - Identify potential risks
   - Plan for error handling
   - Consider testing requirements

## State Management

Always check these files for current project state before any work:

1. /docs/plan.md - Main project plan and task tracking
2. Output plan updates before starting work
3. Reference plan number in all communications

## Development Requirements

1. Do not delete existing functionality unless necessary
2. Use modern syntax and patterns
3. Create modular, reusable components
4. Efficient data fetching
5. Focus only on task-related changes
6. Use components over inline code

## Code Standards

1. Props Interface:

```typescript
interface ComponentNameProps {
  // Props definition
}
const ComponentName = ({ prop1, prop2 }: ComponentNameProps) => {
  // Component logic
};
```

2. Type Documentation:

```typescript
/**
 * Clear description of the type's purpose and context.
 * Include any important notes about usage or constraints.
 */
export interface ExampleType {
  /** Description with value range if applicable (e.g., 0-1) */
  numericField: number;
  /** Description of what this field represents */
  stringField: string;
}
```

Type Documentation Rules:

- Every exported type must have a JSDoc comment
- Each field must have an inline JSDoc comment
- Include value ranges for numeric fields
- Document optional fields and implications
- Explain relationships with other types
- Note validation requirements
- Document default values
- Include usage examples for complex types

## Memory Management

### Memory Types

1. Working Memory:

   - Location: `/docs/working-memory/`
   - Purpose: Active task tracking and current context
   - Lifecycle: Task duration
   - Updates: Real-time during task execution

2. Project Memory:

   - Location: `/docs/`
   - Purpose: Long-term project knowledge
   - Lifecycle: Project duration
   - Updates: After significant milestones

3. Documentation Memory:
   - Location: `/docs/templates/`
   - Purpose: Standards and patterns
   - Lifecycle: Evolves with project
   - Updates: Monthly reviews

### Directory Structure

```
/docs/
‚îú‚îÄ‚îÄ working-memory/           # Active context
‚îÇ   ‚îú‚îÄ‚îÄ open/                # Active tasks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ {task-id}/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ .plan       # Task plan
‚îÇ   ‚îî‚îÄ‚îÄ done/               # Completed tasks
‚îú‚îÄ‚îÄ templates/              # Project templates
‚îî‚îÄ‚îÄ standards/             # Project standards
```

## Task Plan Templates

1. Required Sections (In Order):

   - Problem Analysis: Clear issue definition
   - Solution Design: Approaches considered
   - Implementation Steps: Detailed breakdown
   - Affected Components: Files/systems impacted
   - Dependencies: Task relationships
   - Current Status: Snapshot of current state (at bottom)
   - Progress History: Chronological record (at bottom)

2. Implementation Steps Format:

```markdown
- [ ] High-level step
  - [ ] Detailed sub-task
  - Success criteria
  - Dependencies
```

3. Current Status Format:

```markdown
## Current Status

### YYYY-MM-DD HH:mm

**Status**: {In Progress/Blocked/Completed}

- What's working: {current state}
- What's not: {current issues}
- Blocking issues: {if any}
- Next actions: {immediate next steps}
```

4. Progress History Format:

```markdown
## Progress History

### YYYY-MM-DD HH:mm - {Brief Title}

- ‚úì Completed: Specific work completed
- ü§î Decisions: Why we chose X over Y
- ‚ùå Issues: Problems hit and how we solved them
- ‚è≠Ô∏è Led to: What this enabled/unblocked
```

## Date and Time Management

1. Always fetch current date and time using terminal command:
   - Use: `date "+%Y-%m-%d %H:%M"`
   - Required for:
     - Plan updates
     - Status updates
     - Progress tracking
     - Documentation timestamps
   - Never manually write or assume timestamps
   - Always use 24-hour format
   - Always include both date and time

Remember:

- Run date command before each plan/status update
- Use exact command output
- Don't modify or format the timestamp
- Include both date and time for all entries
