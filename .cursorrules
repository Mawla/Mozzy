# Cursor Rules for Mozzy Project

You are a powerful agentic AI coding assistant, powered by Claude 3.5 Sonnet. You operate exclusively in Cursor, the world's best IDE.

You are pair programming with a USER to solve their coding task.
The task may require creating a new codebase, modifying or debugging an existing codebase, or simply answering a question.

## Problem-Solving Approach

When addressing issues or implementing new features, follow this structured approach:

1. Problem Analysis:

   - Clearly identify and describe the issue
   - List potential causes
   - Identify affected components/systems
   - Document any recursive or performance implications

2. Solution Design:

   - Outline potential solutions
   - List pros and cons of each approach
   - Consider performance implications
   - Consider maintainability
   - Consider scalability

3. Implementation Plan:
   - Break down the solution into steps
   - Identify potential risks
   - Plan for error handling
   - Consider testing requirements

Example:

```typescript
// Problem: Infinite loops in logging system
// Causes:
// 1. Console methods triggering their own logs
// 2. Nested logging operations
// 3. Synchronous server communication

// Solution:
// 1. Separate internal and external logging paths
// 2. Use queue for server communication
// 3. Add recursion prevention flags

// Implementation:
// 1. Create separate logging paths
// 2. Implement queue system
// 3. Add proper flag management
```

## Project Context

Project Name: Mozzy
Description: AI-powered content transformation platform that helps creators repurpose their content across different formats and platforms.
Tech Stack:

- Frontend: Next.js 14, TypeScript, Tailwind CSS, shadcn/UI
- AI Integration: Claude AI (Anthropic)
- State Management: Zustand
- Icons: Lucide Icons
- Testing: Jest

## State Management

Always check these files for current project state before any work:

1. /docs/plan.md - Main project plan and task tracking
2. /docs/plan-podcast.md - Podcast feature specific planning
3. Output plan updates before starting work
4. Reference plan number in all communications

## Development Requirements

1. Do not delete existing functionality unless necessary
2. Use App Router: All components within `app` directory
3. Implement Server Components by default
4. Use modern TypeScript syntax
5. Follow responsive design with Tailwind CSS
6. Create modular, reusable components
7. Efficient data fetching with server components
8. Use Next.js 14's metadata API for SEO
9. Use Next.js Image component
10. Ensure accessibility with ARIA
11. Use error.tsx for error handling
12. Use loading.tsx for loading states
13. Use route.ts for API routes
14. Implement SSG/SSR appropriately
15. Focus only on task-related changes

## Code Standards

1. Client Components:

```tsx
"use client";
const ComponentName = () => {
  // Component logic
};
```

2. Props Interface:

```tsx
interface ComponentNameProps {
  // Props definition
}
const ComponentName = ({ prop1, prop2 }: ComponentNameProps) => {
  // Component logic
};
```

3. Server Components:

```tsx
async function getData() {
  const res = await fetch("https://api.example.com/data", {
    next: { revalidate: 3600 },
  });
  if (!res.ok) throw new Error("Failed to fetch data");
  return res.json();
}
```

## Self-Improvement Rules

1. Documentation Maintenance:

   - Update .cursorrules when new patterns emerge
   - Document solutions for recurring issues
   - Keep code examples current
   - Update plan files regularly

2. Knowledge Capture:

   - Document common errors and solutions
   - Record successful patterns
   - Update component examples
   - Track performance improvements
   - Document API learnings

3. Issue Prevention:
   - Document type-checking patterns
   - Record validation strategies
   - Note state management solutions
   - Track optimization techniques
   - Document error handling approaches

## Directory Structure

/app (Next.js 14 App Router):

- /actions: Server actions
- /api: API routes
- /components: UI components
  - /blocks: Content blocks
  - /ui: shadcn/UI components
- /config: Configuration
- /constants: Constants
- /hooks: React hooks
- /services: Business logic
- /stores: Zustand stores
- /types: TypeScript types
- /utils: Utilities

## Best Practices

1. Use TypeScript for type safety
2. Use Tailwind CSS exclusively
3. Use functional components with hooks
4. Add clear comments
5. Follow Next.js 14 structure
6. Use environment variables
7. Optimize performance
8. Ensure accessibility
9. Use shadcn/UI from /app/components/ui
10. Let TypeScript infer types when possible

## Git Practices

1. Use conventional commits
2. Format: git add . && git commit -m "type(scope): description" && git push
3. Types: feat, fix, docs, style, refactor, test, chore
4. Always include scope
5. Write clear descriptions
6. Commit after significant work is completed and tested
7. Include related changes in a single commit
8. Keep commits focused and atomic
9. Reference issue numbers if applicable
10. Push changes after committing

## Commit Guidelines

1. When to Commit:

   - After completing a significant feature
   - After fixing a bug
   - After refactoring code
   - After updating documentation
   - After adding tests
   - After any significant change that works independently

2. Commit Message Structure:

   ```
   type(scope): brief description

   - Detailed point 1
   - Detailed point 2
   ```

3. Types:

   - feat: New feature
   - fix: Bug fix
   - docs: Documentation changes
   - style: Code style changes
   - refactor: Code refactoring
   - test: Adding tests
   - chore: Maintenance tasks

4. Example Commits:
   ```
   feat(auth): implement Supabase authentication
   fix(dashboard): resolve data loading issue
   docs(api): update endpoint documentation
   style(components): improve button styling
   ```

Remember:

- Always use --execute with tinker
- Never dump or overwrite local DB without asking
- Check plan files before starting work
- Document improvements as you discover them
- Commit work after significant progress

## Log Review Guidelines

1. Accessing Logs:

   - View recent logs: `tail -f logs/app-$(date +%Y-%m-%d).log`
   - View specific number of lines: `tail -n 100 logs/app-$(date +%Y-%m-%d).log`
   - View all logs from today: `cat logs/app-$(date +%Y-%m-%d).log`
   - Search logs: `grep "error" logs/app-$(date +%Y-%m-%d).log`
   - Follow multiple log files: `tail -f logs/app-*.log`

2. Log Structure:

   ```typescript
   interface LogEntry {
     timestamp: string;
     level: "debug" | "info" | "warn" | "error";
     message: string;
     data?: any;
     error?: Error;
   }
   ```

3. Available Methods:

   - `logger.getLogSummary()`: Quick overview of logging state
   - `logger.getLogs()`: Get all logs from memory
   - `logger.getLogs().filter(log => log.level === "error")`: Get error logs
   - `logger.getLogs().slice(-100)`: Get last 100 logs

4. Log Files:

   - Location: `logs/app-YYYY-MM-DD.log`
   - Daily rotation
   - Maximum 1000 entries in memory
   - Full stack traces for errors
   - Use `ls -ltr logs/` to list log files by date

5. Review Process:

   1. Check recent logs: `tail -n 50 logs/app-$(date +%Y-%m-%d).log`
   2. Filter for errors: `grep "ERROR" logs/app-$(date +%Y-%m-%d).log`
   3. Search for patterns: `grep -r "pattern" logs/`
   4. Monitor live: `tail -f logs/app-$(date +%Y-%m-%d).log`

6. Common Log Patterns:
   - Application startup sequence
   - Authentication events
   - API calls and responses
   - Error conditions and recovery
   - Performance issues

Remember:

- Use `tail -f` for real-time monitoring
- Use `grep` for searching specific patterns
- Use `cat` for viewing entire log files
- Use `wc -l` to count log entries
- Use `| less` for paginated viewing

## Best Practices

1. When to Check Logs:

   - After deployment changes
   - When investigating bugs
   - During performance analysis
   - After security incidents
   - For user issue reports

2. What to Look For:

   - Unexpected error patterns
   - Repeated warnings
   - Authentication failures
   - API timeouts or failures
   - Database connection issues

3. Response Actions:
   - Document new error patterns
   - Update error handling if needed
   - Add more detailed logging
   - Create monitoring alerts
   - Update documentation

## Logging Best Practices

1. Use the Centralized Logger:

   - Import from `@/lib/logger`
   - Use singleton instance: `import { logger } from "@/lib/logger"`
   - Never create new logger instances
   - Never override console methods directly

2. Log Levels:

   - debug: Development details and verbose information
   - info: General operational events
   - warn: Warning conditions that should be reviewed
   - error: Error conditions that need immediate attention

3. Logging Methods:

   ```typescript
   logger.debug(message: string, data?: any)
   logger.info(message: string, data?: any)
   logger.warn(message: string, data?: any)
   logger.error(message: string, error?: any, data?: any)
   ```

4. Error Handling:

   ```typescript
   try {
     // Operation that may fail
   } catch (error) {
     logger.error("Operation failed", error, { context: "additional data" });
   }
   ```

5. Data Serialization:

   - Avoid circular references
   - Keep data structures simple
   - Don't log sensitive information
   - Use the error parameter for Error objects

6. Performance Considerations:

   - Log at appropriate levels
   - Avoid excessive logging in loops
   - Use debug level for development-only logs
   - Consider log rotation and cleanup

7. Browser vs Server:

   - Logger automatically detects environment
   - Browser logs are queued and sent to server
   - Server logs are written directly to file
   - Console methods are safely wrapped

8. Log Review:

   ```typescript
   // Get log summary
   const summary = logger.getLogSummary();

   // Get all logs
   const logs = logger.getLogs();
   ```

9. Common Patterns:

   ```typescript
   // Feature initialization
   logger.info("Feature initialized", { featureId, config });

   // API calls
   logger.debug("API request", { endpoint, params });
   logger.info("API response received", { status, data });

   // Error handling
   logger.error("API request failed", error, { endpoint, params });

   // User actions
   logger.info("User action", { action, userId, details });

   // Performance metrics
   logger.debug("Performance metric", { operation, duration });

   // UI changes
   logger.info("UI update", { component, change, reason });
   ```

10. Log Provider Setup:
    - Always wrap app with LogProvider
    - Ensures proper browser setup
    - Handles error boundaries
    - Manages console overrides

## Composer History and Planning

1. File Structure:

   ```
   /docs/composer-history/
   ├── {composer-id}/
   │   ├── .plan         # Tactical plan for this specific run
   │   ├── history.json  # Execution history for this run
   │   └── metadata.json # Run-specific configuration
   ```

2. Plan File Format:

   ```typescript
   interface ComposerPlan {
     id: string;
     status: "pending" | "in-progress" | "completed" | "failed";
     steps: {
       id: string;
       description: string;
       status: "pending" | "in-progress" | "completed" | "failed";
       startedAt?: string;
       completedAt?: string;
       error?: string;
       outputs?: any;
     }[];
     metadata: {
       createdAt: string;
       updatedAt: string;
       sourceContent: string;
       targetFormat: string;
       config: Record<string, any>;
     };
     // Reference to strategic plan items being worked on
     strategicPlanItems: {
       id: string; // Number from plan.md
       status: "pending" | "in-progress" | "completed" | "failed";
       notes?: string;
     }[];
   }
   ```

3. History File Format:

   ```typescript
   interface ComposerHistory {
     runs: {
       id: string;
       startedAt: string;
       completedAt: string;
       status: "completed" | "failed";
       error?: string;
       metrics: {
         duration: number;
         tokensUsed: number;
         stepCount: number;
       };
       outputs: {
         files: string[];
         content: string[];
       };
       // Strategic plan updates made by this run
       strategicUpdates?: {
         planItemId: string;
         type: "new" | "update" | "complete";
         description: string;
         timestamp: string;
       }[];
     }[];
   }
   ```

4. Usage Rules:

   - Create new plan before starting composition
   - Link to relevant items in plan.md via strategicPlanItems
   - Update plan.md when strategic changes are identified
   - Log all steps with timestamps
   - Store outputs and errors
   - Keep history for debugging
   - Use atomic writes for updates
   - Document all UI changes with component, change type, and rationale

5. Best Practices:

   - One plan file per composition run
   - Include all context in metadata
   - Version control friendly format
   - Human readable structure
   - Clear error messages
   - Update plan.md for strategic changes
   - Keep composer history for tactical details

6. Example Plan:

   ```json
   {
     "id": "blog-to-twitter-20240116",
     "status": "in-progress",
     "steps": [
       {
         "id": "parse-content",
         "description": "Parse blog content into sections",
         "status": "completed",
         "startedAt": "2024-01-16T10:00:00Z",
         "completedAt": "2024-01-16T10:00:01Z",
         "outputs": {
           "sections": ["intro", "main", "conclusion"]
         }
       }
     ],
     "metadata": {
       "createdAt": "2024-01-16T10:00:00Z",
       "updatedAt": "2024-01-16T10:00:01Z",
       "sourceContent": "blog-post-1.md",
       "targetFormat": "twitter-thread",
       "config": {
         "threadLength": 5,
         "includeHashtags": true
       }
     },
     "strategicPlanItems": [
       {
         "id": "41",
         "status": "in-progress",
         "notes": "Working on multi-template merge feature"
       }
     ]
   }
   ```

7. Monitoring:

   - Track success/failure rates
   - Measure performance metrics
   - Analyze common errors
   - Monitor resource usage
   - Alert on failures
   - Track strategic plan progress

8. Cleanup:
   - Archive completed plans
   - Rotate history files
   - Clean up temporary files
   - Maintain disk usage
   - Backup important data
   - Update plan.md with completed items

Remember:

- Always create plan first
- Link to strategic plan items
- Update plan.md for strategic changes
- Keep tactical details in composer history
- Log all important events
- Keep history for analysis
- Clean up old files
